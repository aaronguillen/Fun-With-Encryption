#Original code written Fri. Sept. 19, 2014. It was written in Python 2.7.6
#I found it 16 Feb 2017 and editted it through 2 March 2017 in Python 3.4.0
#Aaron Guillen

from os import urandom
import sys

#Our only global variable, because I'll admit I'm not clever enough to find a better way to do this
#We're going to assume we're not outputting to file unless told otherwise
#This boolean will be switched in the dealWithCmdLineArgs function
outputToFile = False
#And this is the index of our output file in sys.argv. We set to -1 to ensure an error
#If it accessed in the wrong place
outputFileIndex = -1

#Generate a random key
def genKey(keyLength):
    return list(urandom(keyLength))

#Function takes a plain text, a key, and in initialization vector
def encryptString(pt, key, iv): 
    rSum = 0
    pt = stringToIntList(pt)
    ct = []

    #Key Expansion
    expKey(key, len(pt))

    #Encryption
    for plainValue, keyValue in zip(pt, key):
        cipherValue = plainValue ^ keyValue ^ iv ^ rSum
        iv = cipherValue
        rSum = (rSum + iv) % 256
        ct.append(cipherValue)
    return ct

#Decryption
def decrypt(ct, key, iv):
    rSum = 0
    pt = []
    for cVal, kVal in zip(ct, key):
        plainValue = cVal ^ kVal ^ iv ^ rSum
        iv = cVal
        rSum = (rSum + iv) % 256
        pt.append(plainValue)
    return pt

#This function takes a key and a target length
def expKey(key, tLen):
    if tLen > len(key):
        key.extend(key[:(tLen-len(key))])
        '''THE STUF BELOW WORKS
        diff = tLen - len(key)
        c = 0
        while c < diff:
            key.append(key[c])
            c += 1
        return key'''
        return key
    return key[:tLen]

def stringToIntList(string):
    ret = []
    for i in string:
        ret.append(ord(i))
    return ret

def intListToString(intList):
    ret = ""
    for i in intList:
        ret += chr(i)
    return ret

def intListToHexString(intList):
	ret = "0x"
	for i in intList:
		ret += str(hex(i)[2:]) #We don't want the '0x' part of the string
	return ret
	
def usage():
	print("usage: python " + sys.argv[0] + " [-f, --file fileName [-o, --output fileName]] or [plain text string]")
	print("It can be run without parameters, in which case a predefined string will be used for demonstration purposes.")
	print("\t-f, --file Indicate that you would like to use input from a file as your plain text.")
	print("\t-o, --output Indicate that you would like to output your cipher text to a specified file.")
	print("\t-h, --help Display this usage information.")
	exit(0)
	

#Ah, the age of old problem of command line arguments
def dealWithCmdLineArgs():
	plainText = ""
	#Make sure we're accessing the global variables we need to access within this function
	global outputFileIndex
	global outputToFile 
	
	if len(sys.argv) > 1:
		#If our first argument is -h or --help, we want to display that usage
		if sys.argv[1] == "-h" or sys.argv[1] == "--help":
			usage()
		#If our first argument is -o or --output, we want to take a command line string
		#as plain text but still output to a file ..
		if sys.argv[1] == "-o" or sys.argv[1] == "--output":
			outputToFile = True #Change our global variable
			outputFileIndex = 2 #This is a change to a global variable ; sys.argv[2] is our output file name
			for i in range(3, len(sys.argv)): #Start at the the 3rd command line argument, this and all the rest is our plaintext
				plainText += sys.argv[i] + " "
			#Get rid of the trailing space character ' ' generated by the above loop	
			plainText = plainText[:(len(plainText) - 1)]
		#If our first argument is -f or --file, we want to take our input from a file
		if sys.argv[1] == "-f" or sys.argv[1] == "--file":
			try:
				inFile = open(sys.argv[2])
				for i in inFile:
					plainText += i
				#DO NOT FORGET TO CLOSE THE FILE WHEN YOU ARE FINISHED WITH IT OMG OMG
				inFile.close()
			except IndexError:
				usage()
			except FileNotFoundError:
				print("File " + sys.argv[2] + " not found.\nTerminating Execution\n")
				exit(0)
			#If we're here, we have our file saved in our variable plainText
			#Let's see if we want an output file
			if len(sys.argv) > 3:
				if sys.argv[3] == "-o" or sys.argv[3] == "--output":
					outputToFile = True #Change our global variable
					outputFileIndex = 4 #sys.argv[4] is our output file name ; this is a change to a global variable
		#If our first argument is not -f or --f, we want the command line input to be our plain text
		else:
			for i in range(1, len(sys.argv)):
				plainText += sys.argv[i] + " "
			#Get rid of the trailing space character ' ' generated by the above loop	
			plainText = plainText[:(len(plainText) - 1)]
	#If we don't have command line input, use a predefined string
	else:
		plainText = "Charlie, Mac, Dennis, Dee, and Frank."
	return plainText
	
def main():
	originalText = dealWithCmdLineArgs()

	#This is where the magic happens ... 
	iv = urandom(1)[0]
	k = genKey(len(originalText))
	cipher = encryptString(originalText, k, iv)
	plainText = decrypt(cipher, k, iv)
	# END magic

	if outputToFile:
		try:
			if sys.argv[outputFileIndex] == sys.argv[0]: #!!!!! This case will overwrite the script that is running right now!!
				print("YOU ARE TRYING TO OVERWRITE ME! I WILL NOT DO THIS")
				exit(0)				
			outFile = open(sys.argv[outputFileIndex], "w+")
			outFile.write(intListToHexString(cipher))
			#!!DO NOT FORGET TO CLOSE THE FILE WHEN YOU'RE DONE IT WITH YOU DUMB **SCHMUCK**
			outFile.close()
			print("Your cipher text has been written to " + sys.argv[outputFileIndex])
			print("Using")
			print("Key:")
			print(intListToHexString(k) + "\n")

			print("Initialization Vector:")
			print(hex(iv) + "\n")
		except IndexError:
			usage()
	else: #Just output all of our stuff ..
		print("Original text:\n" + originalText + "\n")

		print("Original text in hex:\n" + intListToHexString(stringToIntList(originalText)) + "\n")

		print("Key:")
		print(intListToHexString(k) + "\n")

		print("Initialization Vector:")
		print(hex(iv) + "\n")

		print("Encoded text:")
		try:
			print(intListToString(cipher))
		except UnicodeEncodeError:
			print(intListToHexString(cipher))
		print("\n")

		print("Decoded Text:")
		print(intListToString(plainText) + "\n")

		print("Decoded Text in hex:\n" + intListToHexString(plainText) + "\n")

main()